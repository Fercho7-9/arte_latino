import { base64UrlEncode } from '../base64-helper';
/**
 * Interface for Handlers that are hooked in to
 * validate tokens.
 */
export class ValidationHandler {
}
/**
 * This abstract implementation of ValidationHandler already implements
 * the method validateAtHash. However, to make use of it,
 * you have to override the method calcHash.
 */
export class AbstractValidationHandler {
    /**
     * Validates the at_hash in an id_token against the received access_token.
     */
    async validateAtHash(params) {
        const hashAlg = this.inferHashAlgorithm(params.idTokenHeader);
        const tokenHash = await this.calcHash(params.accessToken, hashAlg); // sha256(accessToken, { asString: true });
        const leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);
        const atHash = base64UrlEncode(leftMostHalf);
        const claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');
        if (atHash !== claimsAtHash) {
            console.error('exptected at_hash: ' + atHash);
            console.error('actual at_hash: ' + claimsAtHash);
        }
        return atHash === claimsAtHash;
    }
    /**
     * Infers the name of the hash algorithm to use
     * from the alg field of an id_token.
     *
     * @param jwtHeader the id_token's parsed header
     */
    inferHashAlgorithm(jwtHeader) {
        const alg = jwtHeader['alg'];
        if (!alg.match(/^.S[0-9]{3}$/)) {
            throw new Error('Algorithm not supported: ' + alg);
        }
        return 'sha-' + alg.substr(2);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGlvbi1oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbGliL3NyYy90b2tlbi12YWxpZGF0aW9uL3ZhbGlkYXRpb24taGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFXbkQ7OztHQUdHO0FBQ0gsTUFBTSxPQUFnQixpQkFBaUI7Q0FjdEM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxPQUFnQix5QkFBeUI7SUFNN0M7O09BRUc7SUFDSCxLQUFLLENBQUMsY0FBYyxDQUFDLE1BQXdCO1FBQzNDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFOUQsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQywyQ0FBMkM7UUFFL0csTUFBTSxZQUFZLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUUvRCxNQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFN0MsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXZFLElBQUksTUFBTSxLQUFLLFlBQVksRUFBRSxDQUFDO1lBQzVCLE9BQU8sQ0FBQyxLQUFLLENBQUMscUJBQXFCLEdBQUcsTUFBTSxDQUFDLENBQUM7WUFDOUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsR0FBRyxZQUFZLENBQUMsQ0FBQztRQUNuRCxDQUFDO1FBRUQsT0FBTyxNQUFNLEtBQUssWUFBWSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLGtCQUFrQixDQUFDLFNBQWlCO1FBQzVDLE1BQU0sR0FBRyxHQUFXLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVyQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDO1lBQy9CLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDckQsQ0FBQztRQUVELE9BQU8sTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEMsQ0FBQztDQWFGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmFzZTY0VXJsRW5jb2RlIH0gZnJvbSAnLi4vYmFzZTY0LWhlbHBlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvblBhcmFtcyB7XG4gIGlkVG9rZW46IHN0cmluZztcbiAgYWNjZXNzVG9rZW46IHN0cmluZztcbiAgaWRUb2tlbkhlYWRlcjogb2JqZWN0O1xuICBpZFRva2VuQ2xhaW1zOiBvYmplY3Q7XG4gIGp3a3M6IG9iamVjdDtcbiAgbG9hZEtleXM6ICgpID0+IFByb21pc2U8b2JqZWN0Pjtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIEhhbmRsZXJzIHRoYXQgYXJlIGhvb2tlZCBpbiB0b1xuICogdmFsaWRhdGUgdG9rZW5zLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVmFsaWRhdGlvbkhhbmRsZXIge1xuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBzaWduYXR1cmUgb2YgYW4gaWRfdG9rZW4uXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgdmFsaWRhdGVTaWduYXR1cmUoXG4gICAgdmFsaWRhdGlvblBhcmFtczogVmFsaWRhdGlvblBhcmFtc1xuICApOiBQcm9taXNlPGFueT47XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgYXRfaGFzaCBpbiBhbiBpZF90b2tlbiBhZ2FpbnN0IHRoZSByZWNlaXZlZCBhY2Nlc3NfdG9rZW4uXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgdmFsaWRhdGVBdEhhc2goXG4gICAgdmFsaWRhdGlvblBhcmFtczogVmFsaWRhdGlvblBhcmFtc1xuICApOiBQcm9taXNlPGJvb2xlYW4+O1xufVxuXG4vKipcbiAqIFRoaXMgYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgVmFsaWRhdGlvbkhhbmRsZXIgYWxyZWFkeSBpbXBsZW1lbnRzXG4gKiB0aGUgbWV0aG9kIHZhbGlkYXRlQXRIYXNoLiBIb3dldmVyLCB0byBtYWtlIHVzZSBvZiBpdCxcbiAqIHlvdSBoYXZlIHRvIG92ZXJyaWRlIHRoZSBtZXRob2QgY2FsY0hhc2guXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFZhbGlkYXRpb25IYW5kbGVyIGltcGxlbWVudHMgVmFsaWRhdGlvbkhhbmRsZXIge1xuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBzaWduYXR1cmUgb2YgYW4gaWRfdG9rZW4uXG4gICAqL1xuICBhYnN0cmFjdCB2YWxpZGF0ZVNpZ25hdHVyZSh2YWxpZGF0aW9uUGFyYW1zOiBWYWxpZGF0aW9uUGFyYW1zKTogUHJvbWlzZTxhbnk+O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGF0X2hhc2ggaW4gYW4gaWRfdG9rZW4gYWdhaW5zdCB0aGUgcmVjZWl2ZWQgYWNjZXNzX3Rva2VuLlxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVBdEhhc2gocGFyYW1zOiBWYWxpZGF0aW9uUGFyYW1zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaGFzaEFsZyA9IHRoaXMuaW5mZXJIYXNoQWxnb3JpdGhtKHBhcmFtcy5pZFRva2VuSGVhZGVyKTtcblxuICAgIGNvbnN0IHRva2VuSGFzaCA9IGF3YWl0IHRoaXMuY2FsY0hhc2gocGFyYW1zLmFjY2Vzc1Rva2VuLCBoYXNoQWxnKTsgLy8gc2hhMjU2KGFjY2Vzc1Rva2VuLCB7IGFzU3RyaW5nOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgbGVmdE1vc3RIYWxmID0gdG9rZW5IYXNoLnN1YnN0cigwLCB0b2tlbkhhc2gubGVuZ3RoIC8gMik7XG5cbiAgICBjb25zdCBhdEhhc2ggPSBiYXNlNjRVcmxFbmNvZGUobGVmdE1vc3RIYWxmKTtcblxuICAgIGNvbnN0IGNsYWltc0F0SGFzaCA9IHBhcmFtcy5pZFRva2VuQ2xhaW1zWydhdF9oYXNoJ10ucmVwbGFjZSgvPS9nLCAnJyk7XG5cbiAgICBpZiAoYXRIYXNoICE9PSBjbGFpbXNBdEhhc2gpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2V4cHRlY3RlZCBhdF9oYXNoOiAnICsgYXRIYXNoKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2FjdHVhbCBhdF9oYXNoOiAnICsgY2xhaW1zQXRIYXNoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXRIYXNoID09PSBjbGFpbXNBdEhhc2g7XG4gIH1cblxuICAvKipcbiAgICogSW5mZXJzIHRoZSBuYW1lIG9mIHRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2VcbiAgICogZnJvbSB0aGUgYWxnIGZpZWxkIG9mIGFuIGlkX3Rva2VuLlxuICAgKlxuICAgKiBAcGFyYW0gand0SGVhZGVyIHRoZSBpZF90b2tlbidzIHBhcnNlZCBoZWFkZXJcbiAgICovXG4gIHByb3RlY3RlZCBpbmZlckhhc2hBbGdvcml0aG0oand0SGVhZGVyOiBvYmplY3QpOiBzdHJpbmcge1xuICAgIGNvbnN0IGFsZzogc3RyaW5nID0gand0SGVhZGVyWydhbGcnXTtcblxuICAgIGlmICghYWxnLm1hdGNoKC9eLlNbMC05XXszfSQvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbGdvcml0aG0gbm90IHN1cHBvcnRlZDogJyArIGFsZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICdzaGEtJyArIGFsZy5zdWJzdHIoMik7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgaGFzaCBmb3IgdGhlIHBhc3NlZCB2YWx1ZSBieSB1c2luZ1xuICAgKiB0aGUgcGFzc2VkIGhhc2ggYWxnb3JpdGhtLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVUb0hhc2hcbiAgICogQHBhcmFtIGFsZ29yaXRobVxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGNhbGNIYXNoKFxuICAgIHZhbHVlVG9IYXNoOiBzdHJpbmcsXG4gICAgYWxnb3JpdGhtOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxzdHJpbmc+O1xufVxuIl19